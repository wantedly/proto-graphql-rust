# 概要

TODO: 箇条書きから文章へ変換

## 何をするツールか

- protoを解析して、「graphqlによるリクエストを単に適切なgRPCサービスにプロキシ/ルーティングする単純なサービス」を生成する
  - 生成されたサービスをサーブしたり、gRPCサービスへのconnectionを作成するところは手動
    - ただ、これはある程度定型文なので、構成ファイル(yml, tomlなど)と組み合わせて自動化できると思う
  - 生成されたサービスは対応するgRPCサービスと1対1なので、複数のサービスにファンアウトするような処理はできないはず
    - コメントでprotoにアノテーションを付ければサービス間のリレーションみたいなのを表現できると思うけどまだそこらへんのgraphqlの機能をわかってない

## なんでサービスジェネレータ作ったのか

- visit-api-nodeとwantedly-bff-graphqlの問題の多くは自動化・機械化できない処理に関することだった
  - Rustだとどの程度自動化できるのか、またRustにかかわらずこれらを自動化する時の問題点みたいなのがわかればいいかな、という感じ
- graphqlもBFFもこのタスクで初めて触れた程度の知識
  - フロントエンドは簡単なネイティブのデスクトップアプリしか書いたことないので、そもそもフロントエンド側の気持ちがわかってない
- タスク開始から発表まで4日間しかない！（重要）
- コードを入力として受け取って、編集、加工したコードを出力するような処理をRustで書くのに慣れていた

## どこまでできたの?

- [wantedly/apis](https://github.com/wantedly/apis)に含まれる全てのprotoに対応するBFFサービスのRustコードは生成できる。
  - なお、リリースモードでのコンパイル時間は割と悲惨なことになる
    - というか、rust-analyzer（もしくはそれが呼び出してるclippy）が時々ハングする
- 動作確認はローカルで後述の例のようなサーバを使用しただけで、実際のサービスでは動作確認してない。
  - 一応ほとんどの種類のprotoオブジェクトをテストしたはずだけど見逃してるのもあるかもしれない
  - graphqlのresolverがどのように機能してるかは使用したgraphqlサーバライブラリに丸投げしたので(Rustだと構造体や関数に属性マクロを置くだけである程度自動的にコードを生成してくれる)、「これが機能するとは思ってなかった」みたいなのはあるかもしれない(もちろん逆もありえる)

## 未解決、未到達な点

- 「未到達」はそもそも検証できてない点、ある程度予想はつくケースもある
- 「未解決」はやろうとしたが解決できなかった点
- 未到達: サービス間のリレーション周りを生成するところまでは到達しなかった
  - 単純にこのへんの領域の知識をインプットできてない
  - graphqlサーバライブラリにはそれらしい機能があるようなので、コメントでprotoにアノテーションを付けて解析させればできるのではないかと楽観的に考えてる
  - ただし、そのアノテーションを付ける作業と対応するコードを生成させるコードを書くのがどれだけ大変なのかは不明
- 未到達: 実際のサービスでの動作確認
  - 動作確認の方法を探す時間がなかった
- 未解決: naming
  - 自動生成するにはある程度原則が必要
    - 今回は暫定的なものを使用したけど
    - GraphQL に関するベストプラクティスがない
