<!--
https://github.com/wantedly/dx/issues/328#issuecomment-781953959 での発表で使用した資料のコピー
-->

# インターンタスク2: visit-api-node (wantedly-bff-graphql) をRustで書く技術検証

issue: https://github.com/wantedly/dx/issues/330

https://github.com/wantedly/bff-graphql-rust

- What?
  - visit-api-nodeを置き換えるBFFサーバをrustで書く場合に何が必要か、どのような問題があるのか等を検証する

- Why?
  - 現在本番環境で動作しているbffサーバであるvisit-api-nodeには色々問題がある
    - https://github.com/wantedly/visit-api-node
    - https://github.com/wantedly/dev/issues/345
    - https://github.com/wantedly/dev/issues/204#issuecomment-669642074
      - バックエンドから見ると、単にプロトコル（というかオブジェクト）変換用のプロキシサーバが生まれただけに見えている
        - さらに変換コードを手動で書く必要があり面倒
      - スキーマの2重管理
        - Profileでは以前はprotoがmasterで、プロトを見れば全てわかるという仕様書的な形でも使用されていた
        - 現在は2重masterのような状態でGraphQLスキーマを手動でprotoの変更に追従させている
        - protoからGraphQLスキーマを生成するような機能が欲しい
      - 学習、レビュー、設計のコストの増大
        - protoの知識とGraphQL/フロントエンドの知識の両方が必要
        - GraphQL に関するベストプラクティスがない
        - スキーマ設計のコスト
        - レビューコスト
      - etc
  - 既存のPOCであるwantedly-bff-graphqlはある程度これを改善できる
    - https://github.com/wantedly/wantedly-bff-graphql
    - デザインドキュメント：https://github.com/wantedly/wantedly-bff-graphql/issues/1
    - proto-graphql/proto-nexus の思想と基本動作と解決しそうな問題：https://github.com/wantedly/wantedly-bff-graphql/issues/23
      - protoからgraphqlを生成できる
      - proto → graphql のオブジェクト変換ができる
      - gRPCリクエストを叩くmutationは手動で書く必要がある
  - 別の言語で書くとどうなの? 例えばRustでは？

## まとめ

- what is BFF
  (Backends For Frontends（フロントエンドのためのバックエンド)の略。
  バックエンドのマイクロサービスを集約してフロントエンドへのエントリーポイントとして機能するようなサーバ。
  この図がイメージしやすいかもしれない：https://microservices.io/i/apigateway.jpg
  （出典：https://microservices.io/patterns/apigateway.html）

- 今回作ったもの：proto firstのbffサービスジェネレータ

  - protoを解析して、「graphqlによるリクエストを単に適切なgRPCサービスにプロキシ/ルーティングする単純なサービス」を生成する
    - 生成されたサービスをサーブしたり、gRPCサービスへのconnectionを作成するところは手動
      - ただ、これはある程度定型文なので、構成ファイル(yml, tomlなど)と組み合わせて自動化できると思う
    - 生成されたサービスは対応するgRPCサービスと1対1なので、複数のサービスにファンアウトするような処理はできないはず
      - コメントでprotoにアノテーションを付ければサービス間のリレーションみたいなのを表現できると思うけどまだそこらへんのgraphqlの機能をわかってない

  - Question: なんでサービスジェネレータ作ったの？〇〇の方がよかったのでは？
    - visit-api-nodeとwantedly-bff-graphqlの問題の多くは自動化・機械化できない処理に関することだった
      - Rustだとどの程度自動化できるのか、またRustにかかわらずこれらを自動化する時の問題点みたいなのがわかればいいかな、という感じ
    - graphqlもBFFもこのタスクで初めて触れた程度の知識
      - フロントエンドは簡単なネイティブのデスクトップアプリしか書いたことないので、そもそもフロントエンド側の気持ちがわかってない
    - タスク開始から発表まで4日間しかない！（重要）
    - コードを入力として受け取って、編集、加工したコードを出力するような処理をRustで書くのに慣れていた

  - Question: どこまでできたの?
    - [wantedly/apis](https://github.com/wantedly/apis)に含まれる全てのprotoに対応するBFFサービスのRustコードは生成できる。
      - なお、リリースモードでのコンパイル時間は割と悲惨なことになる
        - というか、rust-analyzer（もしくはそれが呼び出してるclippy）が時々ハングする
    - 動作確認はローカルで後述の例のようなサーバを使用しただけで、実際のサービスでは動作確認してない。
      - 一応ほとんどの種類のprotoオブジェクトをテストしたはずだけど見逃してるのもあるかもしれない
      - graphqlのresolverがどのように機能してるかは使用したgraphqlサーバライブラリに丸投げしたので(Rustだと構造体や関数に属性マクロを置くだけである程度自動的にコードを生成してくれる)、「これが機能するとは思ってなかった」みたいなのはあるかもしれない(もちろん逆もありえる)

  - 未解決、未到達な点
    - 「未到達」はそもそも検証できてない点、ある程度予想はつくケースもある
    - 「未解決」はやろうとしたが解決できなかった点
    - 未到達: サービス間のリレーション周りを生成するところまでは到達しなかった
      - 単純にこのへんの領域の知識をインプットできてない
      - graphqlサーバライブラリにはそれらしい機能があるようなので、コメントでprotoにアノテーションを付けて解析させればできるのではないかと楽観的に考えてる
      - ただし、そのアノテーションを付ける作業と対応するコードを生成させるコードを書くのがどれだけ大変なのかは不明
    - 未到達: 実際のサービスでの動作確認
      - 動作確認の方法を探す時間がなかった
    - 未解決: naming
      - 自動生成するにはある程度原則が必要
        - 今回は暫定的なものを使用したけど
        - GraphQL に関するベストプラクティスがない
    -

  - 使用例

      `proto/helloworld.proto`

      ```proto
      syntax = "proto3";

      package helloworld;

      service Greeter {
        rpc SayHello (HelloRequest) returns (HelloReply) {}
      }

      message HelloRequest {
        string name = 1;
      }

      message HelloReply {
        string message = 1;
      }
      ```

      ビルドスクリプト(コンパイル時に実行されるプログラム) 。
      コンパイル時にprotoファイルを読んでRustコードを生成する。

      `build.rs`

      ```rust
      fn main() {
          proto_graphql_build::compile_protos("proto/helloworld.proto").unwrap();
      }
      ```

    生成されるコード：https://github.com/wantedly/bff-graphql-rust/blob/0ff22e938919b9a9b39c580956475bdd336639ed/examples/src/generated/helloworld.rs

      bffサーバ
      `src/bin/bff-server.rs`

      ```rust
      use std::{convert::Infallible, net::SocketAddr};

      use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};
      use async_graphql_warp::{BadRequest, Response};
      use warp::{http::Response as HttpResponse, Filter, Rejection};

      use pb::{greeter_client::GreeterClient, greeter_graphql_schema::GreeterGraphQlSchema};

      mod pb {
          // protoから生成されたRustコードをインポート
          tonic::include_proto!("helloworld");
      }

      #[tokio::main]
      async fn main() -> Result<()> {
          let addr: SocketAddr = "[::1]:50051".parse().unwrap();
          println!("bff-server listening on {}", addr);

          // gRPC clientに接続
          let grpc_client = GreeterClient::connect("http://[::1]:50051").await?;

          // gRPC clientからGraphQL schemaでラップする
          // 生成されたGraphQL schemaに含まれるmutationは対応するgRPCサービスのメソッドを呼び出すだけ
          let schema = grpc_client.into_graphql_schema();

          // .sdl()メソッドで実際のGraphQL schemaを取得できる
          println!("GraphQL schema:\n{}", schema.sdl());

          // GraphQLサービスの作成
          let graphql_post = async_graphql_warp::graphql(schema).and_then(
              |(schema, request): (GreeterGraphQlSchema<_>, async_graphql::Request)| async move {
                  // requestとresponseのデータはここで操作できる
                  // 例：https://github.com/async-graphql/examples/blob/b36b5c44543b7323cb199ed229ea247e83b85d18/warp/token-from-header/src/main.rs#L37-L51
                  // Request: https://docs.rs/async-graphql/2/async_graphql/struct.Request.html
                  // Response: https://docs.rs/async-graphql/2/async_graphql/struct.Response.html
                  Ok::<_, Infallible>(Response::from(schema.execute(request).await))
              },
          );

          // GraphQL playgroundで使用できるようにする
          let graphql_playground = warp::path::end().and(warp::get()).map(|| {
              HttpResponse::builder()
                  .header("content-type", "text/html")
                  .body(playground_source(GraphQLPlaygroundConfig::new("/")))
          });

          // webサーバを実行
          let routes = graphql_playground.or(graphql_post);
          warp::serve(routes).run(addr).await;

          Ok(())
      }
      ```

      gRPCサーバ
      `src/bin/grpc-server.rs`

      ```rust
      use tonic::{transport::Server, Request, Response, Status};

      use pb::greeter_server::{Greeter, GreeterServer};
      use pb::{HelloReply, HelloRequest};

      mod pb {
          // protoから生成されたRustコードをインポート
          tonic::include_proto!("helloworld");
      }

      #[derive(Default)]
      struct MyGreeter {}

      // gRPCサーバの定義
      #[tonic::async_trait]
      impl Greeter for MyGreeter {
          async fn say_hello(
              &self,
              request: Request<HelloRequest>,
          ) -> Result<Response<HelloReply>, Status> {
              println!("Got a request from {:?}", request.remote_addr());
              let reply = HelloReply {
                  message: format!("Hello {}!", request.into_inner().name),
              };
              Ok(Response::new(reply))
          }
      }

      #[tokio::main]
      async fn main() -> Result<()> {
          let addr = "[::1]:50052".parse().unwrap();
          println!("grpc-server listening on {}", addr);

          let greeter = MyGreeter::default();

          // gRPCサーバを実行
          Server::builder()
              .add_service(GreeterServer::new(greeter))
              .serve(addr)
              .await?;

          Ok(())
      }
      ```

      実行

      ```console
      $ cargo run --bin grpc-server
      grpc-server listening on [::1]:50052
      ```

      ```console
      $ cargo run --bin bff-server
      bff-server listening on [::1]:50051
      graphql schema:
      type NoopQuery {
              _noop: Empty!
      }
      type Empty {
              _noop: Boolean
      }
      type GreeterMutation {
              sayHello(request: HelloRequestInput!): HelloReply!
      }
      input HelloRequestInput {
      name: String!
      }
      type HelloReply {
              message: String!
      }
      schema {
              query: NoopQuery
              mutation: GreeterMutation
      }
      ```

      (`.sdl()`メソッドが返すgraphql schemaで`input`がきちんとフォーマットされてないのは多分バグ)

      GraphQL Playgroundまたは他のツールで`http://[::1]:50051`にmutationを投げる。

      ```graphql
      mutation {
        sayHello(request:{name:"GraphQL"}){
          message
        }
      }
      ```

      ```json
      {
        "data": {
          "sayHello": {
            "message": "Hello GraphQL!"
          }
        }
      }
      ```

      ```console
      $ curl 'http://[::1]:50051' -H 'Accept-Encoding: gzip, deflate, br' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Origin: file://' --data-binary '{"query":"mutation {\n  sayHello(request:{name:\"o\"}){\n    message\n  }\n}"}' --compressed
      {"data":{"sayHello":{"message":"Hello o!"}}}
      ```

  - protoを読み込んで以下を生成
    - GraphQLオブジェクトに対応するRustコード
      - これはprotoオブジェクトに対応するRustコード（後述）をベースに生成する
        - コード生成例

            次のようなprotoオブジェクトに対応するRustコードから

            ```rust
            /// Two RepositorySlug are considered as equal when both `user` and `name` are equal
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RepositorySlug {
                #[prost(string, tag = "1")]
                pub user: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
            }
            ```

            次のようなGraphQLオブジェクトに対応するRustコードを生成する

            ```rust
            /// Two RepositorySlug are considered as equal when both `user` and `name` are equal
            #[derive(
                Clone,
                PartialEq,
                ::async_graphql::SimpleObject,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[graphql(name = "RepositorySlug")]
            pub struct RepositorySlugGraphQl {
                pub user: ::prost::alloc::string::String,
                pub name: ::prost::alloc::string::String,
            }
            /// Two RepositorySlug are considered as equal when both `user` and `name` are equal
            #[derive(
                Clone,
                PartialEq,
                ::async_graphql::InputObject,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[graphql(name = "RepositorySlugInput")]
            pub struct RepositorySlugGraphQlInput {
                pub user: ::prost::alloc::string::String,
                pub name: ::prost::alloc::string::String,
            }
            ```

            これは次のGraphQLオブジェクトに対応する

            ```graphql
            type RepositorySlug {
                user: String!
                name: String!
            }
            input RepositorySlugInput {
                user: String!
                name: String!
            }
            ```

        - GraphQLオブジェクトに対応させるために必要な実装（(de)serializeなど）は`#[derive(::async_graphql::SimpleObject)]`および`#[derive(::async_graphql::InputObject)]`によって生成される
        - `#[graphql(name = "RepositorySlugInput")]`はGraphQLでの名前を指定する
          - Rustコード上では「protoオブジェクトに対応するRustコード」と「GraphQLオブジェクトに対応するRustコード」が同じ名前空間に生成されているためRustコード上での名前には「GraphQl」という名前が入る
          - Rustのモジュールやprotoのparentメッセージのようなものの対応物がGraphQlにはないので、いずれにしても名前を調整する必要がある
            - このparentメッセージをどうGraphQlオブジェクトの名前に変換するかは後述
        - GraphQlだと（Output）ObjectとInputObjectは別の型なので、rust上でもそのように表現される。
          - Inputとしても使用されるのかOutputのみなのかは基本的にはわからないので、今回の実装では常に両方を生成している
            - コメントを読んで「Output only」みたいなのがあればInputObjectは生成しないようにするようなコードを書くことは可能
            - どちらにしても、実際に使用されない場合はGraphQlスキーマには現れない

    - protoオブジェクトとGraphQLオブジェクトの変換の実装
      - protoオブジェクトとGraphQLオブジェクトをどちらもRustのstruct・enumとして表現できるので、それを相互変換するコードを生成するだけ。
        - コード生成例

            ```rust
            impl From<RepositorySlug> for RepositorySlugGraphQl {
                fn from(other: RepositorySlug) -> Self {
                    let RepositorySlug { user, name, .. } = other;
                    Self {
                        user: user.into(),
                        name: name.into(),
                    }
                }
            }
            impl From<RepositorySlugGraphQl> for RepositorySlug {
                fn from(other: RepositorySlugGraphQl) -> Self {
                    let RepositorySlugGraphQl { user, name } = other;
                    Self {
                        user: user.into(),
                        name: name.into(),
                    }
                }
            }
            ```

        - Rustだとこの辺の変換はFromとIntoというtraitで大体表現できる
        - 失敗する可能性のある変換もあるので、TryFromとTryIntoを使うように書き換えた方がいいかも
        - mapとかoptionは単に`.into()`を呼びだすだけでは変換できないけど、この辺はフィールドの型を元に調整できる
    - GraphQLクエリをgRPCリクエストに変換するGraphQL mutation
    - これらはprost-buildという.protoファイルからRustコードを生成するためのライブラリを使用
      - ドキュメント：https://docs.rs/prost-build/0.7.0/prost_build/index.html
      - prost-buildが直接サポートしているのはprotoからprotoオブジェクトに対応するrustコードを生成することだけだが、ユーザ側で拡張できるように設計されている
        - 今回はこれのサービス生成機能を使用
        - ドキュメント：https://docs.rs/prost-build/0.7.0/prost_build/struct.Config.html#method.service_generator
      - 一部のコードはprost-buildに一度コードを生成させてからそれを編集、追加する形で生成している
    - さらに以下を今回作ったライブラリで使用したツールによって同時に生成
      - protoオブジェクトに対応するrustコード
        - コード生成例
            例えば次のprotoメッセージから

            ```proto
            message ConditionFeedback {
              // Required.
              uint64 sender_user_id = 1;
              // Deprecated.  未回答フィードバックの実装に伴って廃止予定。
              // 今後はreceiver_user_id, company_id, beginning_of_weekをもとにConditionを特定する。
              uint64 condition_id = 2 [deprecated = true];
              // Optional.
              google.protobuf.StringValue message = 3;
              // Optional.
              google.protobuf.StringValue emoji = 4;
              // Required.
              uint64 receiver_user_id = 5;
              // Required.
              uint64 company_id = 6;
              // Required.
              google.type.Date beginning_of_week = 7;
            }
            ```

            次のRust構造体を生成

            ```rust
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ConditionFeedback {
                /// Required.
                #[prost(uint64, tag = "1")]
                pub sender_user_id: u64,
                /// Deprecated.  未回答フィードバックの実装に伴って廃止予定。
                /// 今後はreceiver_user_id, company_id, beginning_of_weekをもとにConditionを特定する。
                #[deprecated]
                #[prost(uint64, tag = "2")]
                pub condition_id: u64,
                /// Optional.
                #[prost(message, optional, tag = "3")]
                pub message: ::core::option::Option<::prost::alloc::string::String>,
                /// Optional.
                #[prost(message, optional, tag = "4")]
                pub emoji: ::core::option::Option<::prost::alloc::string::String>,
                /// Required.
                #[prost(uint64, tag = "5")]
                pub receiver_user_id: u64,
                /// Required.
                #[prost(uint64, tag = "6")]
                pub company_id: u64,
                /// Required.
                #[prost(message, optional, tag = "7")]
                pub beginning_of_week: ::core::option::Option<super::super::super::google::r#type::Date>,
            }
            ```

        - これはprost-buildによって生成される
        - proto messageへの(de)serializeに必要な実装は`#[derive(::prost::Message)]`によって生成される
        - Required、Optional、Deprecatedなどのコメントが解析され、型やアノテーションが調整される。
          - ただし、まだ微妙にバグがあるようで、例えば上の例の`beginning_of_week`はRequiredなのにOptionalとして生成されている。
            - 関連するバグレポート：https://github.com/danburkert/prost/issues/437
            - 今回作ったライブラリにprost-buildが生成したコードを解析して調整するステップがあるので、この辺はその一部として修正可能なはず
          - メッセージオプションはサポートされていない
            - 関連する機能リクエスト：https://github.com/danburkert/prost/issues/425
            - ただし、前述のように、prost-buildが生成したコードを解析して調整するステップがあるので、そこでコメントに基づいてカスタマイズすることは可能。
      - gRPCサービス（サーバおよびクライアント）
        - tonic-buildというprost-buildの同じ機能を使用する別のライブラリによって生成
        - tonic-buildはサービス生成部分を独立した関数としても使用できるように公開していて、それを今回作ったサービスジェネレータのサービス生成プロセス内で呼びだすという形で使用した
          - [tonic_build::client::generate](https://docs.rs/tonic-build/0.4.0/tonic_build/client/fn.generate.html)
          - [tonic_build::server::generate](https://docs.rs/tonic-build/0.4.0/tonic_build/server/fn.generate.html)
        - tonic-buildは[wantedly/apis-rust](https://github.com/wantedly/apis-rust)でも使用されている

- 考察：RustのGraphQLエコシステム
  - [juniper](https://crates.io/crates/juniper)と[async-graphql](https://crates.io/crates/async-graphql)の2つのGraphQLサーバライブラリがメジャー
    - juniperはより長い歴史があり広く使用されている。
    - async-graphqlは新しいがより積極的にメンテナンスされているように見える。
    - 今回の検証ではasync-graphqlを使用した。理由は主に以下
      - juniperがtokio（rustのもっとも広く使用される非同期ランタイム）の最新バージョンに未対応であった
      - juniperのいくつかのマクロ関連のバグに遭遇した（おそらく簡単なバグなので、時間があれば修正を提出する予定）
      - async-graphqlの主要なメンテナは2人ともGitHub/Rustコミュニティ上で非常にアクティブであり、問題があった場合に何らかの応答が得られる可能性が高いと考えた
    - どちらのライブラリもRust code firstで、スキーマからrustコードを生成するのではなく、rustコードからスキーマを組み立てるような形になる
      - juniperにはGraphQLスキーマから対応するrustコードを生成できるライブラリがある。
        - https://github.com/davidpdrsn/juniper-from-schema
        - ただし、最新のjuniperのサポートはまだリリースされていない（masterにはある）
    - [古いバージョンのjuniperはRust構文とはかなり異なるDSLを書く必要があった](https://docs.rs/juniper/0.14.2/juniper/macro.graphql_object.html#examples)ようだが、最新バージョンでは必要なくなったようなので、少しAPIを見た感じではそれほどasync-graphqlとjuniperの間に基本的な使いやすさの違いはないかもしれない（juniperを実際に触ったわけではないので詳細はわからない）

- おまけ：RustのgRPCエコシステム
  - 以下の4つがメジャー
    - [grpc-rs](https://github.com/tikv/grpc-rs) - The gRPC library for Rust built on C Core library and futures
    - [grpc-rust](https://github.com/stepancheg/grpc-rust) - Rust implementation of gRPC
    - [tower-grpc](https://github.com/tower-rs/tower-grpc) - A client and server gRPC implementation based on Tower
    - [tonic](https://github.com/hyperium/tonic) - A native gRPC client & server implementation with async/await support
    - 出典：https://github.com/grpc-ecosystem/awesome-grpc#rust
  - tower-grpcはtonicの元の名前で、現在は非推奨
  - grpc-rsはPingCAPによってメンテナンスされていて、tikvなどで使用されているが、以前にtikvのメンテナの人が「tower-grpcに切り替えたい」みたいなこと言ってた
    - https://medium.com/@siddontang/use-tower-grpc-for-tikv-6109cf8c61

      > - grpc-rs is not pure Rust
      > - Its performance is not very good. It is slower than our customized protocol.
      > - Sadly, we even met some panic in gRPC in production environments before.

  - grpc-rustは個人のプロジェクトでかなり古くからある
    - メンテナが1人だけなので開発が止まりがちな印象
  - tonicはtower-grpcの置き換えとして作られた
    - メインのメンテナはAWSの人で、他にもEmbark Studiosの人が何人か開発に関わってる
  - tonicは[wantedly/refine-image-rust](https://github.com/wantedly/refine-image-rust)でも使用されている

- 考察：proto -> GraphQL スキーマ変換
  - 全体的にhttps://github.com/wantedly/wantedly-bff-graphql/issues/23#issuecomment-769476148 を参考にした
  - protoのmessageとenumはほぼそのままGraphQLのtypeとenumに変換できる。
  - ややこしいのはprotoでサポートされているが、GraphQLでサポートされていないか、似ているが仕様が異なるようなオブジェクト
  - proto oneof -> GraphQL union
    - GraphQL unionのフィールドの型は他のフィールドと異なる型である必要がある。
      - 例えば以下のproto oneofはGraphQL unionにそのまま変換できない

        ```proto
        oneof OneOf {
          string A = 10;
          string B = 11;
        }
        ```

      - 今回の実装では個々のフィールドに対して新しいtypeを定義することで回避した

        ```graphql
        union OneOf = OneOfA | OneOfB
        type OneOfA {
          a: String!
        }
        type OneOfB {
          b: String!
        }
        ```

        元のフィールド名が生成されたtypeのsuffixとそのフィールド名として残ってる。
        この辺のnamingはもっといいのがありそう。

  - unionのフィールドにオブジェクト以外を置けないみたいな問題があって、一個上の問題に対処したのとほぼ同じ方法で処理したはずなんだけど詳細覚えてない。
  - Inputでunionを使用できない
    - proto oneofはリクエストとレスポンスの両方で使用できるがGraphQL unionはレスポンス(output)のみ。
    - これについては公式リポジトリを含め色々と議論されているよう(私が読み間違えていなければ、受け入れられたけど実装はされていない、という状況。)
      - https://github.com/graphql/graphql-spec/issues/488
      - https://brunoscheufler.com/blog/2019-05-19-reaching-consensus-graphql-input-union
    - 今回の実装ではasync-graphqlのissueでメンテナがこの制限の回避策として使用していると述べた方法を採用した。
      - https://github.com/async-graphql/async-graphql/issues/373#issuecomment-753761917
      - これは https://github.com/graphql/graphql-spec/issues/488 で「Directive」と呼ばれている方法と基本的に同じ
        - フィールドの型が重複するunionをサポートできるという利点があるが、スキーマでの表現（複数のオプションフィールドをもつtype）と実際の処理（union）が異なるなどの欠点がある。
        - また、実際にオブジェクト変換を実装する際に（複数のフィールドが同時に指定されていないか）チェックが必要。
  - GraphQLは空のオブジェクトをサポートしていない
    - 例えば次のproto

        ```proto
        message Empty {
        }
        ```

    - これも色々と議論されている。
      - https://github.com/graphql/graphql-spec/issues/568
      - https://github.com/graphql/graphql-js/issues/937
    - 実際には実装依存で、許可してる実装もあるよう。
      - https://github.com/graph-gophers/graphql-go/issues/209
    - RustのGraphQLサーバ実装はどちらも現在は許可していない。
      - https://github.com/async-graphql/async-graphql/issues/315
      - https://github.com/graphql-rust/juniper/issues/172
    - これの主な回避策は https://github.com/graphql/graphql-spec/issues/568 と https://github.com/graphql/graphql-js/issues/937 で言及されているように、Booleanのnoopフィールドを使用する方法。
      - 今回の実装ではそれを採用した。次のgraphql typeに変換される

        ```graphql
        type Empty {
          _noop: Boolean
        }
        ```

      - wantedly-bff-graphqlも同じ方法を採用してるよう: https://github.com/wantedly/wantedly-bff-graphql/blob/06be39beeafac58b44985140651c23bcccc08d4e/src/__generated__/schema.graphql#L1188
    - クエリが一つも定義されていないのもだめなのでこれについてもNoopQueryを定義して回避してる。
  - mapなどのGraphQLではサポートされていない型
    - scalar（input/ouputは文字列だけどアプリケーション内では解析された型として使用できる型）を使用する
    - async-graphqlにはjsonに(de)serialize可能な型をラップする便利な[async_graphql::Json](https://docs.rs/async-graphql/2.5.4/async_graphql/types/struct.Json.html)型があったのでそれを使用した。
      - juniperにも同じようなものがあるかは十分には調べてない。
        - 多分なさそう？https://github.com/graphql-rust/juniper/issues/280
  - Rustのモジュールやprotoのparentメッセージのようなものの対応物がGraphQlにはない
    - GraphQlオブジェクトの名前を調整する必要がある
    - 今回の実装では単一のprotoファイルをルートとして扱って、そこからのparentメッセージをRoot側から順に全て名前のprefixとして追加してある
      - 例えば次のprotoのInnerメッセージは「ParentInner」になる

        ```proto
        message Parent {
          string value = 1;
          message Inner {
            string value = 1;
          }
        }
        ```

        ```graphql
        type Parent {
          value: String!
        }
        type ParentInner {
          value: String!
        }
        ```

    - 単一のprotoファイルではなく、パッケージ名を解析すればもっと良さそう
  - (他にも色々あったはずだけど覚えてないので思い出したら書きます)
